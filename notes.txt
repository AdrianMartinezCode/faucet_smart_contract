We use the ganache tool as a local ethereum blockchain.

To link the ganache to our project, we have to go to the truffle-config.js and configure the correct ip address.
And go to the contracts section on the ganache, and link this file truffle-config.js.
This provokes that the smart contracts that we did will appear on this section.


To compile the contracts:
> truffle compile

To migrate the contract, we should create a migration file for every contract, named:

[#number]_[contract name]_migration.js

Into this file, the basic migration code is:

const FaucetContract = artifacts.require("Faucet"); // <-- name of the smart contract, this line set as a variable our smart contract

module.exports = function (deployer) { // <-- set the default function for this file the deploying of the smart contract passing by argument the deployer, the deployer is injected automatically by the migration agent
    deployer.deploy(FaucetContract);
}

To compile and migrate contracts:
> truffle migrate





web3: is a collection of libs that allow you to interact with
a local or remote ethereum node.

https://web3js.readthedocs.io/en/v1.7.5/

To access to the faucet console:
> cd /home/adrian/solidity_course/faucet
> truffle console

To get the contract instance:
> const instance = new web3.eth.Contract(Faucet.abi, "0x11D8c3EC90f60614879a5E33fEAE3Ba49510bc70")


Retrieve the funds variable from a contract:
> const funds = await instance.methods.funds().call()


If you run:

> truffle console
> accounts

You will see the accounts on the ganache that you own, avaliable in the context.

https://web3js.readthedocs.io/en/v1.2.11/web3-eth.html#sendtransaction

How to create a transaction

Convert units:
https://eth-converter.com/

If you type on the truffle console:
> web3.eth.sendTransaction({from: accounts[0], to: "0x2af9Cf8b00293E1654Fb0F008e588691A046780a", value: "10000000000000000000"})

This sends 10 eth to the account hardcoded.

THis command allows you to show the information about the nth block:
> web3.eth.getBlock("9")


Transactions visualizer:

http://ethviewer.live/

The bubbles indicates the transactions on the mempool.


You can search for certain transaction here:

https://etherscan.io/


The nonce number is incremented for every block
The nonce number must be larger of the target
Is used to guarantee the preservation from the information of the blocks.
Is a combination with the hash.
Is a random number that guarantees the old hashes aren't be able to reuse.

you can see the definition of the old pow algorithm from ethereum:
https://ethereum.org/es/developers/docs/consensus-mechanisms/pow/mining-algorithms/ethash/#mining


Blockchain datastructure simulator:
https://andersbrownworth.com/blockchain/blockchain


Ethereum yellow paper:
https://ethereum.github.io/yellowpaper/paper.pdf

Ethereum block arquitecture:
https://ethereum.stackexchange.com/questions/268/ethereum-block-architecture


We can decode a certain transaction on the ethereum blockchain:
https://toolkit.abdk.consulting/ethereum#transaction

https://github.com/Jerga99/faucet-course/commit/2cc3a2115e85f2ee044617dff0d9668e0d06977d


-------------------

You can send funds to an ethereum smart contract just putting their contract addres on the to field:

web3.eth.sendTransaction({from: accounts[0], to: "0x2B2541AFDA826DeaB68B4391Dc3677B33098cd30", data: ""})

You must provide the function signature getting the hash from the function name with:
https://emn178.github.io/online-tools/keccak_256.html

And getting the first 4 bytes of the name:

addFunds() -> a26759cbc968c68c5eb5853f763227a619bc9612320b36b21463d21f1dc9ec98

Extract: 0xa26759cb

And provide it to the data field:

web3.eth.sendTransaction({from: accounts[0], to: "0x2B2541AFDA826DeaB68B4391Dc3677B33098cd30", data: "0xa26759cb", value: "3000000000000000000"})

If you see the bytecode, you can find this 0xa26759cb signature as a push command of this signature.
Data is the function that will be executed on the moment that we make the transaction.



-------------------------------------------
Example of smart contract:
// SPDX-License-Identifier: MIT
pragma solidity >=0.4.22 <0.9.0;

contract Faucet {
    // this is a special function
    // it's called when you make a tx that doesn't specify
    //  function name to call

    // External function are part of the contract interface
    //  which means they can be called via contracts and other txs

    // external keyword means: can be called from the outside
    // payable keyword means: provide ether in the tx
    receive() external payable {}

    // If you try to use this command on the truffle console:
    // instance.addFunds({value: "2000000000000000000"})
    // if you didn't make the function payable, this will crash
    function addFunds() external payable {}

    // pure, view - read-only call, no gas fee
    // view - it indicates that the function won't alter the storage state in any way
    // pure - even more strict, indicating that it won't even read the storage state
    function justTesting() external pure returns(uint) {
        return 2 + 2;
    }

    // Transactions (can generate state changes) and require gas fee
    // read-only call, no gas fee

    // to talk to the node on the network you can make JSON-RPC http calls
    


}

// Block info
// Nonce - a hash that when combined with the minHash proofs that
// the block has gone through proof of work(POW)
// 8 bytes => 64 bits

------------------------------------------

On the truffle console to access to certain position of the memory:

const instance = await Storage.deployed()
// the first parameter is the smart contract address:
web3.eth.getStorageAt("0xc30369Ca553f5441adD4B7ec0a6eE6d6491e2A84", 0)


--------------------------------------------
// SPDX-License-Identifier: MIT
pragma solidity >=0.4.22 <0.9.0;

contract Faucet {

    address[] private funders;

    // private -> can be accesible only within the smart contract
    //  on the bytecode we won't found the signature!!
    // internal -> can be accesible within smart contract and also derived smart contract

    receive() external payable {}
    function addFunds() external payable {
        funders.push(msg.sender);
    }

    function getAllFunders() public view returns (address[] memory) {
        return funders;
    }

    function getFunderAtIndex(uint8 index) external view returns (address) {
        address[] memory _funders = getAllFunders();
        return _funders[index];
    }
}

// const instance = await Faucet.deployed();
// instance.addFunds({from: accounts[0], value: "2"})
-----------------------------------


// SPDX-License-Identifier: MIT
pragma solidity >=0.4.22 <0.9.0;

contract Faucet {

    uint public numOfFunders;
    mapping(uint => address) private funders;

    receive() external payable {}
    function addFunds() external payable {
        uint index = numOfFunders++;
        funders[index] = msg.sender;
    }

    function getAllFunders() external view returns (address[] memory) {
        address[] memory _funders = new address[](numOfFunders);

        for (uint i = 0; i < numOfFunders; i++) {
            _funders[i] = funders[i];    
        }

        return _funders;
    }

    function getFunderAtIndex(uint8 index) external view returns (address) {
        return funders[index];
    }
}

// const instance = await Faucet.deployed();
// instance.addFunds({from: accounts[0], value: "20000000000"})
// instance.addFunds({from: accounts[1], value: "20000000000"})
// instance.getFunderAtIndex(0);

----------------------------------------------------------